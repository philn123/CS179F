diff --git a/kernel/file.c b/kernel/file.c
index e8dcf17..00579b7 100644
--- a/kernel/file.c
+++ b/kernel/file.c
@@ -16,7 +16,7 @@
 struct devsw devsw[NDEV];
 struct {
   struct spinlock lock;
-  struct file file[NFILE];
+
 } ftable;
 
 void
@@ -29,18 +29,17 @@ fileinit(void)
 struct file*
 filealloc(void)
 {
-  struct file *f;
-
   acquire(&ftable.lock);
-  for(f = ftable.file; f < ftable.file + NFILE; f++){
-    if(f->ref == 0){
-      f->ref = 1;
-      release(&ftable.lock);
-      return f;
-    }
+  struct file *p = bd_malloc(sizeof(struct file));
+
+  if(p == 0){
+    release(&ftable.lock);
+    return 0;
   }
+  memset(p,0,sizeof(struct file));
+  p->ref = 1;
   release(&ftable.lock);
-  return 0;
+  return p;
 }
 
 // Increment ref count for file f.
@@ -60,7 +59,6 @@ void
 fileclose(struct file *f)
 {
   struct file ff;
-
   acquire(&ftable.lock);
   if(f->ref < 1)
     panic("fileclose");
@@ -80,6 +78,8 @@ fileclose(struct file *f)
     iput(ff.ip);
     end_op(ff.ip->dev);
   }
+  
+  bd_free(f);
 }
 
 // Get metadata about file f.
diff --git a/kernel/param.h b/kernel/param.h
index 8e4ca98..eb2c034 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -12,3 +12,4 @@
 #define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
 #define NDISK        2
+#define FILESIZE     48
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..e9420c1 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -47,8 +47,29 @@ sys_sbrk(void)
   if(argint(0, &n) < 0)
     return -1;
   addr = myproc()->sz;
-  if(growproc(n) < 0)
+
+  // if (addr + n > MAXVA)
+  // {
+  //   return -1;
+  // }
+
+  if(n < 0){
+    if(growproc(n) < 0)
+    {
+      return -1;
+    }
+  }
+  else
+  {
+    myproc()->sz += n;
+  }
+
+  if (myproc()->sz > MAXVA || myproc()->sz < 0)
+  {
     return -1;
+  }
+
+  
   return addr;
 }
 
diff --git a/kernel/trap.c b/kernel/trap.c
index 51a7805..18c9ac5 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -68,11 +68,43 @@ usertrap(void)
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    p->killed = 1;
+    if (r_scause() == 13 || r_scause() == 15)
+    {
+      uint64 fault_va = r_stval();
+      uint64 round_fva = PGROUNDDOWN(fault_va);
+
+      if (fault_va >= p->sz || fault_va <= p->tf->sp || round_fva >= MAXVA)
+      {
+        p->killed = 1;
+        goto exit;
+      }
+
+      char *mem = kalloc();
+
+      if (mem == 0)
+      {
+        p->killed = 1;
+        goto exit;
+      }
+
+      memset(mem, 0, PGSIZE);
+
+      if(mappages(p->pagetable, round_fva, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)
+      {
+        kfree(mem);
+        p->killed = 1;
+        goto exit;
+      }
+    }
+    else
+    {
+      printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+      printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+      p->killed = 1;
+    }
   }
 
+  exit:
   if(p->killed)
     exit(-1);
 
diff --git a/kernel/vm.c b/kernel/vm.c
index 2b99c8b..514164c 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,7 +5,8 @@
 #include "riscv.h"
 #include "defs.h"
 #include "fs.h"
-
+#include "spinlock.h"
+#include "proc.h"
 /*
  * the kernel's page table.
  */
@@ -185,10 +186,12 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 size, int do_free)
   last = PGROUNDDOWN(va + size - 1);
   for(;;){
     if((pte = walk(pagetable, a, 0)) == 0)
-      panic("uvmunmap: walk");
+      goto end1;
+      // panic("uvmunmap: walk");
     if((*pte & PTE_V) == 0){
-      printf("va=%p pte=%p\n", a, *pte);
-      panic("uvmunmap: not mapped");
+      goto end1;
+      // printf("va=%p pte=%p\n", a, *pte);
+      // panic("uvmunmap: not mapped");
     }
     if(PTE_FLAGS(*pte) == PTE_V)
       panic("uvmunmap: not a leaf");
@@ -196,7 +199,9 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 size, int do_free)
       pa = PTE2PA(*pte);
       kfree((void*)pa);
     }
+
     *pte = 0;
+    end1:
     if(a == last)
       break;
     a += PGSIZE;
@@ -319,9 +324,11 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
+      continue;
+      //panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
+      continue;
+      //panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
     if((mem = kalloc()) == 0)
@@ -363,11 +370,45 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
   while(len > 0){
     va0 = (uint)PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
+
     if(pa0 == 0)
-      return -1;
+    {
+      struct proc* p = myproc();
+      uint64 round_fva = PGROUNDDOWN(va0);
+
+      if (va0 >= p->sz || va0 <= p->tf->sp || round_fva >= MAXVA)
+      {
+        return -1;
+      }
+
+      char* mem = kalloc();
+
+      if (mem == 0)
+      {
+        return -1;
+      }
+
+      memset(mem, 0, PGSIZE);
+
+      if(mappages(p->pagetable, round_fva, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)
+      {
+        kfree(mem);
+        return -1;
+      }
+
+      pa0 = (uint64) mem;
+
+    }
+
     n = PGSIZE - (dstva - va0);
     if(n > len)
       n = len;
+
+    if (pa0 + (dstva - va0) > MAXVA || pa0 + (dstva - va0) < 0)
+    {
+      return -1;
+    }
+
     memmove((void *)(pa0 + (dstva - va0)), src, n);
 
     len -= n;
@@ -388,11 +429,44 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
   while(len > 0){
     va0 = (uint)PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
+
     if(pa0 == 0)
-      return -1;
+    {
+      struct proc* p = myproc();
+      uint64 round_fva = PGROUNDDOWN(va0);
+
+      if (va0 >= p->sz || va0 <= p->tf->sp || round_fva >= MAXVA)
+      {
+        return -1;
+      }
+
+      char* mem = kalloc();
+
+      if (mem == 0)
+      {
+        return -1;
+      }
+
+      memset(mem, 0, PGSIZE);
+
+      if(mappages(p->pagetable, round_fva, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)
+      {
+        kfree(mem);
+        return -1;
+      }
+
+      pa0 = (uint64) mem;
+    }
+
     n = PGSIZE - (srcva - va0);
     if(n > len)
       n = len;
+    
+    if (pa0 + (srcva - va0) > MAXVA || pa0 + (srcva - va0) < 0)
+    {
+      return -1;
+    }
+
     memmove(dst, (void *)(pa0 + (srcva - va0)), n);
 
     len -= n;
@@ -415,12 +489,44 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
   while(got_null == 0 && max > 0){
     va0 = (uint)PGROUNDDOWN(srcva);
     pa0 = walkaddr(pagetable, va0);
+    
     if(pa0 == 0)
-      return -1;
+    {
+      struct proc* p = myproc();
+      uint64 round_fva = PGROUNDDOWN(va0);
+
+      if (va0 >= p->sz || va0 <= p->tf->sp || round_fva >= MAXVA)
+      {
+        return -1;
+      }
+
+      char* mem = kalloc();
+
+      if (mem == 0)
+      {
+        return -1;
+      }
+
+      memset(mem, 0, PGSIZE);
+
+      if(mappages(p->pagetable, round_fva, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)
+      {
+        kfree(mem);
+        return -1;
+      }
+
+      pa0 = (uint64) mem;
+    }
+
     n = PGSIZE - (srcva - va0);
     if(n > max)
       n = max;
 
+    if (pa0 + (srcva - va0) > MAXVA || pa0 + (srcva - va0) < 0)
+    {
+      return -1;
+    }
+
     char *p = (char *) (pa0 + (srcva - va0));
     while(n > 0){
       if(*p == '\0'){
diff --git a/mycode.diff b/mycode.diff
new file mode 100644
index 0000000..6d4b5d8
--- /dev/null
+++ b/mycode.diff
@@ -0,0 +1,185 @@
+diff --git a/kernel/file.c b/kernel/file.c
+index e8dcf17..00579b7 100644
+--- a/kernel/file.c
++++ b/kernel/file.c
+@@ -16,7 +16,7 @@
+ struct devsw devsw[NDEV];
+ struct {
+   struct spinlock lock;
+-  struct file file[NFILE];
++
+ } ftable;
+ 
+ void
+@@ -29,18 +29,17 @@ fileinit(void)
+ struct file*
+ filealloc(void)
+ {
+-  struct file *f;
+-
+   acquire(&ftable.lock);
+-  for(f = ftable.file; f < ftable.file + NFILE; f++){
+-    if(f->ref == 0){
+-      f->ref = 1;
+-      release(&ftable.lock);
+-      return f;
+-    }
++  struct file *p = bd_malloc(sizeof(struct file));
++
++  if(p == 0){
++    release(&ftable.lock);
++    return 0;
+   }
++  memset(p,0,sizeof(struct file));
++  p->ref = 1;
+   release(&ftable.lock);
+-  return 0;
++  return p;
+ }
+ 
+ // Increment ref count for file f.
+@@ -60,7 +59,6 @@ void
+ fileclose(struct file *f)
+ {
+   struct file ff;
+-
+   acquire(&ftable.lock);
+   if(f->ref < 1)
+     panic("fileclose");
+@@ -80,6 +78,8 @@ fileclose(struct file *f)
+     iput(ff.ip);
+     end_op(ff.ip->dev);
+   }
++  
++  bd_free(f);
+ }
+ 
+ // Get metadata about file f.
+diff --git a/kernel/param.h b/kernel/param.h
+index 8e4ca98..eb2c034 100644
+--- a/kernel/param.h
++++ b/kernel/param.h
+@@ -12,3 +12,4 @@
+ #define FSSIZE       2000  // size of file system in blocks
+ #define MAXPATH      128   // maximum file path name
+ #define NDISK        2
++#define FILESIZE     48
+diff --git a/kernel/sysproc.c b/kernel/sysproc.c
+index e8bcda9..e9420c1 100644
+--- a/kernel/sysproc.c
++++ b/kernel/sysproc.c
+@@ -47,8 +47,29 @@ sys_sbrk(void)
+   if(argint(0, &n) < 0)
+     return -1;
+   addr = myproc()->sz;
+-  if(growproc(n) < 0)
++
++  // if (addr + n > MAXVA)
++  // {
++  //   return -1;
++  // }
++
++  if(n < 0){
++    if(growproc(n) < 0)
++    {
++      return -1;
++    }
++  }
++  else
++  {
++    myproc()->sz += n;
++  }
++
++  if (myproc()->sz > MAXVA || myproc()->sz < 0)
++  {
+     return -1;
++  }
++
++  
+   return addr;
+ }
+ 
+diff --git a/kernel/trap.c b/kernel/trap.c
+index 51a7805..18c9ac5 100644
+--- a/kernel/trap.c
++++ b/kernel/trap.c
+@@ -68,11 +68,43 @@ usertrap(void)
+   } else if((which_dev = devintr()) != 0){
+     // ok
+   } else {
+-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+-    p->killed = 1;
++    if (r_scause() == 13 || r_scause() == 15)
++    {
++      uint64 fault_va = r_stval();
++      uint64 round_fva = PGROUNDDOWN(fault_va);
++
++      if (fault_va >= p->sz || fault_va <= p->tf->sp || round_fva >= MAXVA)
++      {
++        p->killed = 1;
++        goto exit;
++      }
++
++      char *mem = kalloc();
++
++      if (mem == 0)
++      {
++        p->killed = 1;
++        goto exit;
++      }
++
++      memset(mem, 0, PGSIZE);
++
++      if(mappages(p->pagetable, round_fva, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0)
++      {
++        kfree(mem);
++        p->killed = 1;
++        goto exit;
++      }
++    }
++    else
++    {
++      printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
++      printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
++      p->killed = 1;
++    }
+   }
+ 
++  exit:
+   if(p->killed)
+     exit(-1);
+ 
+diff --git a/kernel/vm.c b/kernel/vm.c
+index 2b99c8b..514164c 100644
+--- a/kernel/vm.c
++++ b/kernel/vm.c
+@@ -5,7 +5,8 @@
+ #include "riscv.h"
+ #include "defs.h"
+ #include "fs.h"
+-
++#include "spinlock.h"
++#include "proc.h"
+ /*
+  * the kernel's page table.
+  */
+@@ -185,10 +186,12 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 size, int do_free)
+   last = PGROUNDDOWN(va + size - 1);
+   for(;;){
+     if((pte = walk(pagetable, a, 0)) == 0)
+-      panic("uvmunmap: walk");
++      goto end1;
++      // panic("uvmunmap: walk");
+     if((*pte & PTE_V) == 0){
+-      printf("va=%p pte=%p\n", a, *pte);
+-      panic("uvmunmap: not mapped");
++      goto end1;
++      // printf("va=%p pte=%p\n", a, *pte);
++      // panic("uvmunmap: not mapped");
+     }
+     if(PTE_FLAGS(*pte) == PTE_V)
+       panic("uvmunmap: not a leaf");
+@@ -196,7 +199,9 @@ uvmunmap(pagetable_t pagetable, uint64 va, uint64 size, int do_free)
+       pa = PTE2PA(*pte);
+       kfree((void*)p
\ No newline at end of file
